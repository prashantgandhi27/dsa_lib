////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2024 Prashant Gandhi - All rights are reserved
////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef PRASHANT_MILKY_WAY_STACK_STACK_H
#define PRASHANT_MILKY_WAY_STACK_STACK_H

////////////////////////////////////////////////////////////////////////////////////////////////////
// Include(s)
////////////////////////////////////////////////////////////////////////////////////////////////////
#include <initializer_list>
#include <utility>

////////////////////////////////////////////////////////////////////////////////////////////////////
// Namespace(s)
////////////////////////////////////////////////////////////////////////////////////////////////////
namespace Prashant
{
namespace MilkyWay
{

////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief Stack container.
////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
class Stack
{
private:
   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Node to store element.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   struct Node
   {
      Node(Element_type const& rc_node_data)
         : m_data_node{ rc_node_data }
         , m_next_node{ nullptr }
      {
         // Intentionally left empty.
      }

      Element_type m_data_node;
      Node* m_next_node;
   };

public:
   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Default constructor.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   Stack() = default;

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Parametrized constructor.
   ///
   /// @param[in] rc_element_list The list of elements to push into container.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   explicit Stack(std::initializer_list<Element_type> const& rc_element_list);

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Default destructor.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   ~Stack();

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Copy constructor.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   Stack(Stack const&);

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Copy assignment.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   Stack& operator=(Stack const&);

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Copy constructor.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   Stack(Stack&&) noexcept;

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Copy assignment.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   Stack& operator=(Stack&&) noexcept;

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Move constructor.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   bool operator==(Stack const&) const;

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Move assignment.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   bool operator!=(Stack const&) const;

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Pushes element at the top of the container.
   ///
   /// @param[in] rc_data The element that needs to be pushed.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   void push(Element_type const& rc_data);

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Provided top element of the container.
   ///
   /// @return Top most element of the container if container is non-empty, otherwise undefined
   ///         behaviour.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   Element_type top() const;

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Removes top element from the container.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   void pop();

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Removes all elements from the container.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   void clear();

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Provides number of elements present in the container.
   ///
   /// @return Number of elements present in the container.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   size_t size() const;

   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Checks whether or not container is empty.
   ///
   /// @return True if container is empty, otherwise false.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   bool is_empty() const;

private:
   /////////////////////////////////////////////////////////////////////////////////////////////////
   /// @brief Checks whether or not container is empty.
   ///
   /// @return True if container is empty, otherwise false.
   /////////////////////////////////////////////////////////////////////////////////////////////////
   void copy_stack(Stack<Element_type>::Node const* pc_starting_node);

   Stack<Element_type>::Node* m_head{ nullptr };
   size_t m_total_elements{ 0U };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Stack class implementation.
////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
Stack<Element_type>::Stack(std::initializer_list<Element_type> const& rc_element_list)
{
   for (auto const& element : rc_element_list)
   {
      this->push(element);
   }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
Stack<Element_type>::~Stack()
{
   this->clear();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
Stack<Element_type>::Stack(Stack<Element_type> const& rhs)
{
   if (this != &rhs)
   {
      this->clear();
      this->copy_stack(rhs.m_head);
   }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
typename Stack<Element_type>& Stack<Element_type>::operator=(Stack<Element_type> const& rhs)
{
   if (this != &rhs)
   {
      this->clear();
      this->copy_stack(rhs.m_head);
   }

   return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
Stack<Element_type>::Stack(Stack<Element_type>&& rhs) noexcept
{
   if (this != &rhs)
   {
      this->clear();
      this->m_head           = rhs.m_head;
      this->m_total_elements = rhs.m_total_elements;

      rhs.m_head           = nullptr;
      rhs.m_total_elements = 0U;
   }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
typename Stack<Element_type>& Stack<Element_type>::operator=(Stack<Element_type>&& rhs) noexcept
{
   if (this != &rhs)
   {
      this->clear();
      this->m_head           = rhs.m_head;
      this->m_total_elements = rhs.m_total_elements;

      rhs.m_head           = nullptr;
      rhs.m_total_elements = 0U;
   }

   return *this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
bool Stack<Element_type>::operator==(Stack<Element_type> const& rhs) const
{
   auto result{ true };
   if (this != &rhs)
   {
      if (this->size() != rhs.size())
      {
         result = false;
      }
      else
      {
         Stack<Element_type>::Node* this_stack_current_node = this->m_head;
         Stack<Element_type>::Node* rhs_stack_current_node  = rhs.m_head;

         while ((this_stack_current_node != nullptr) && (rhs_stack_current_node != nullptr))
         {
            if (rhs_stack_current_node->m_data_node != this_stack_current_node->m_data_node)
            {
               result = false;
               break;
            }

            this_stack_current_node = this_stack_current_node->m_next_node;
            rhs_stack_current_node  = rhs_stack_current_node->m_next_node;
         }
      }
   }

   return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
bool Stack<Element_type>::operator!=(Stack<Element_type> const& rhs) const
{
   return !((*this) == rhs);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
size_t Stack<Element_type>::size() const
{
   return this->m_total_elements;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
bool Stack<Element_type>::is_empty() const
{
   return (0U == this->m_total_elements);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
void Stack<Element_type>::push(Element_type const& rc_element)
{
   if (this->is_empty())
   {
      this->m_head = new Stack<Element_type>::Node(rc_element);
   }
   else
   {
      Stack<Element_type>::Node* new_top_node = new Stack<Element_type>::Node(rc_element);
      new_top_node->m_next_node               = this->m_head;
      this->m_head                            = new_top_node;
   }

   ++this->m_total_elements;

   return;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
Element_type Stack<Element_type>::top() const
{
   if (this->is_empty())
   {
      return Element_type{};
   }

   return this->m_head->m_data_node;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
void Stack<Element_type>::pop()
{
   if (this->is_empty())
   {
      return;
   }

   Stack<Element_type>::Node* temp_node_ptr = this->m_head;
   this->m_head                             = this->m_head->m_next_node;

   delete temp_node_ptr;
   --this->m_total_elements;

   return;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
void Stack<Element_type>::clear()
{
   while (!this->is_empty())
   {
      this->pop();
   }

   return;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename Element_type>
void Stack<Element_type>::copy_stack(Stack<Element_type>::Node const* pc_starting_node)
{
   while (!this->is_empty())
   {
      this->clear()
   }

   while (pc_starting_node != nullptr)
   {
      this->push(pc_starting_node->m_data_node);
      pc_starting_node = pc_starting_node->m_next_node;
   }

   return;
}

}  // namespace MilkyWay
}  // namespace Prashant

#endif  // PRASHANT_MILKY_WAY_STACK_STACK_H
